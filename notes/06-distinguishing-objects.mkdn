
It'd be nice to be able to determine, given a point that is believed to be on
the surface of an object, *which* object owns the surface.  This would enable
coloring, different material properties, etc.

It might also be useful to determine, given *any* point, one of the nearest
objects.  This could be used for e.g. voronoi volume rendering.  Which is mostly
for fun I think.

Note that, for most distance field evaluations in a raymarcher, the "which
object" information is irrelevant and is likely to be thrown away.  It is only
when a surface is found that the information is needed.

Thus it may make sense to generate *two* distance field evaluators, for
performance reasons: one which returns distance, and one which returns object
identifiers / properties.

Though it'd likely need to return distance too.  Imagine that we return
(distance, ID) pairs from the leaf primitives.  How do the CSG operations work?

Union:

    vec2 did1 = object1(q);
    vec2 did2 = object2(q);
    return (did1.x < did2.x) ? did1 : did2;

Intersection:

    vec2 did1 = object1(q);
    vec2 did2 = object2(q);
    return (did1.x > did2.x) ? did1 : did2;

Hm.  So in general, we apply the conditioning and/or selection logic to the
distance component as always, but carry the corresponding vector along with it.
Doesn't really matter whether it's a vec2 or a big matrix.  Though of course
smaller is probably cheaper.


So once we *have* an OID, what do we do with it?

Well, we could store colors in a 1D texture, indexed by OID.

We could also store Phong material properties in the same way.

We could add a second render target where each pixel holds an OID.  The CPU
could then look up in that framebuffer to figure out which object is under a
given location (e.g. the mouse cursor).



-----------------

Okay.  Here's a path forward.

- Alter the 'node' struct so that leaf nodes can have an ID.
  - Combinators may or may not have IDs.  Not sure yet.

- Add a pass that gives every leaf node a unique ID.
  - Possible optimization: identify nodes that are similarly styled, collapse.
    - This makes mouse selection less accurate.

- Define a way of setting the color of leaves in a subtree.
  - Likely a combinator.

- Add a pass that collects (ID, color) pairs.

- Generate an alternate evaluator that returns the ID in addition to the
  distance.
  - Its callers probably won't use the distance, but it needs to track it
    internally for CSG purposes.

For sphere-tracing specifically:

- Figure out how many IDs are assigned.

- Generate a 1D texture of the next power of two.

- Fill in its pixels with the appropriate colors.

- In the fragment shader, identify the ID on hit and look up the color.

As a first step, I could procedurally color nodes to prove that discrimination
works.
