#lang racket/gui

(require racket/runtime-path)

(require (planet "rgl.rkt" ("stephanh" "RacketGL.plt" 1 4)))
(require ffi/vector)

(require "../core/compiler/canon.rkt")
(require "../core/compiler/enumerate.rkt")
(require "../core/math.rkt")
(require "../core/model.rkt")
(require "../lang/evaluator.rkt")
(require "../lang/loader.rkt")
(require "./glsl.rkt")
(require "./spheretrace-viewer.rkt")

; ------------------------------------------------------------------------------
; Globals used for program state.

; The filesystem path to the design file.  Initially received as a command line
; argument and stored here to support reloading.
(define design-path #f)

; The OpenGL handle to the current shader program.  This is set at reload, when
; a new shader gets compiled.
(define program #f)

; A thunk that will clean up and delete the current shader program.  This is
; also set at reload.
(define delete-program void)

; The OpenGL handle to the texture used to communicate node colors to the
; shader.  Set during setup.
(define colors-texture #f)

; A Racket byte-string the same size as the colors texture.  We fill this in
; with a new copy of the texture and then upload it using 'glTexImage2D'.
(define colors-buffer #f)


; ------------------------------------------------------------------------------
; Design loading and compilation.

; Loads, compiles, and links a shader program, reading the preamble text from
; 'preamble-port' and generating the shader for the current design.  This
; triggers a reload.
;
; If a program has been generated by a previous call to this function, it gets
; deleted.
(define (load-program preamble-port)
  (when program
    (delete-program)
    (set! program #f)
    (set! delete-program void))

  (let* ([program (glCreateProgram)]
         [shader (glCreateShader GL_FRAGMENT_SHADER)]
         [lines (load-program-source shader preamble-port)])
    (glCompileShader shader)

    ; Check for compilation success.
    (if (= (get-shader-parameter shader GL_COMPILE_STATUS) GL_TRUE)
      (begin
        ; On success, finish installing the shader and return both the program
        ; and its destruction thunk.
        (glAttachShader program shader)
        (glLinkProgram program)
        (printf "Shader program ~a compiled and linked.~n" program)
        (values
          program
          (lambda ()
            (printf "Detaching shader ~a from program ~a~n" shader program)
            (glDetachShader program shader)
            (printf "Marking shader ~a for deletion.~n" shader)
            (glDeleteShader shader)
            (printf "Marking program ~a for deletion.~n" program)
            (glDeleteProgram program))))
      (begin
        ; On error, print the full text of the generated shader, along with any
        ; error message recieved from the graphics stack.
        (for ([line lines]) (displayln line))
        (error 'load-program "error compiling: ~a" (get-shader-info-log shader))
        (glDeleteShader shader)
        (glDeleteProgram program)
        (values #f void)))))

; Loads the preamble source from 'preamble-port', generates the shader for the
; current design, and installs them as the shader source code for 'shader'.
;
; Returns the complete source as a vector of lines, for error reporting.
(define (load-program-source shader preamble-port)
  ; Even though we give OpenGL a list of strings, they are not treated as lines
  ; for error reporting!  To get line numbers in error output, we must ensure
  ; that every line ends with a newline character.
  (let* ([preamble (for/vector ([line (in-lines preamble-port)])
                     (string-append line "\n"))]
         [gen (for/vector ([line (in-list (reload design-path))])
                (string-append line "\n"))]
         [lines (vector-append preamble gen)]
         [sizes (for/list ([line (in-vector lines)]) (string-length line))]
         [sizes (list->s32vector sizes)])
   (glShaderSource shader (vector-length lines) lines sizes)
   lines))

; Reloads the design at 'path', recompiling it to GLSL and regenerating its
; metadata texture(s).
(define (reload path)
  (printf "Recompiling design at ~a~n" path)
  (let ([gen (load-frep path)])
    (unless (procedure? gen)
      ; This handles silly cases like '(define design 3)`.
      (error "Design at" path "binds 'design', but not to a procedure."))

    (let*-values ([(cn) (first (canonicalize (call-with-edsl-root gen)))]
                  [(count node) (enumerate-nodes 0 cn)])
      (printf "Design contains ~a nodes.~n" count)
      (update-colors-texture node)
      (append
        (node->glsl-distance node)
        (node->glsl-disc node)))))

; Updates the colors texture with the appropriate colors for children of 'node'.
(define (update-colors-texture node)
  (for ([i (in-range (* 512 512 3))])
    (bytes-set! colors-buffer i #xAA))
  (printf "Collecting node colors for texture...~n")
  (collect-node-colors
    node
    (lambda (nid color)
      (bytes-set! colors-buffer
                  (* 3 nid)
                  (exact-floor ((first color) . * . 255)))
      (bytes-set! colors-buffer
                  (+ 1 (* 3 nid))
                  (exact-floor ((second color) . * . 255)))
      (bytes-set! colors-buffer
                  (+ 2 (* 3 nid))
                  (exact-floor ((third color) . * . 255)))))
  (glActiveTexture GL_TEXTURE0)
  (glBindTexture GL_TEXTURE_2D colors-texture)
  ; Yes, these parameters really need to be set, despite only using
  ; texelFetch.
  (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MAG_FILTER GL_NEAREST)
  (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MIN_FILTER GL_NEAREST)
  (glTexImage2D GL_TEXTURE_2D 0
                GL_RGB
                512 512 0 GL_RGB GL_UNSIGNED_BYTE
                colors-buffer)
  (printf "Texture updated.~n"))

; Simple traversal routine that calls 'out-fn' with each 'node-id' and
; 'node-color' for any child of 'node' that has them defined.
(define (collect-node-colors node out-fn)
  (when ((node-id node) . and . (node-color node))
    (out-fn (node-id node) (node-color node)))

  (for ([child (node-children node)])
    (collect-node-colors child out-fn)))


; ------------------------------------------------------------------------------
; OpenGL utilities.

; Utility for getting integer shader parameters by name.
(define (get-shader-parameter shader pname)
  (let ([v (s32vector 0)])
    (glGetShaderiv shader pname v)
    (s32vector-ref v 0)))

; Utility for loading the compiler output.
(define (get-shader-info-log shader)
  (let ([log-length (get-shader-parameter shader GL_INFO_LOG_LENGTH)])
    (let-values ([(actual-length info-log)
                  (glGetShaderInfoLog shader log-length)])
      (bytes->string/utf-8 info-log #\? 0 actual-length))))

; Utilities for locating and setting uniforms.
(define (set-uniform-1i program name value)
  (glUniform1i (glGetUniformLocation program name) value))

(define (set-uniform-bool program name value)
  (set-uniform-1i program name (if value 1 0)))

(define (set-uniform-1f program name value)
  (glUniform1f (glGetUniformLocation program name)
               (real->double-flonum value)))

(define (set-uniform-2f program name value1 value2)
  (glUniform2f (glGetUniformLocation program name)
               (real->double-flonum value1)
               (real->double-flonum value2)))

(define (set-uniform-4f program name value1 value2 value3 value4)
  (glUniform4f (glGetUniformLocation program name)
               (real->double-flonum value1)
               (real->double-flonum value2)
               (real->double-flonum value3)
               (real->double-flonum value4)))



; ------------------------------------------------------------------------------
; Program wiring.

; Path anchor for finding 'preamble.glsl'.  This forces a correct path to be
; generated at compile time, and includes the file in any generated packages.
(define-runtime-path preamble-glsl "./preamble.glsl")

; Setup thunk passed to gl-viewer.  Called on initial setup and again at
; reload.
(define (setup)
  ; Lazily allocate the buffer used to upload the colors texture.  We never
  ; reset this, so it only happens on first 'setup'.
  (unless colors-buffer
    (set! colors-buffer (make-bytes (* 512 512 3))))
  ; Lazily allocate the actual colors texture.  Likewise, this only happens on
  ; first 'setup'.
  (unless colors-texture
    (set! colors-texture (u32vector-ref (glGenTextures 1) 0)))

  ; Load and compile the design if this machine supports it.
  (if (or (gl-version-at-least? '(2 0))
          (gl-has-extension? 'GL_ARB_shader_objects))
    (set!-values (program delete-program)
                 (call-with-input-file preamble-glsl load-program))
    (printf "This OpenGL does not support shaders, you'll get a plain white rectangle.~%"))

  ; Return the view modes we understand.
  '(shaded complexity distance))

; Draw routine called by gl-viewer to produce new frames.
(define (draw width height orientation zoom quality step-limit mode)
  ; We'll fill the screen with a quad, used simply to hang our fragment shader
  ; upon.  These are the corners.
  (define vertex-array
    (f64vector 0.0 0.0
               width 0.0
               width height
               0.0 height))

  (when program
    (glUseProgram program)

    ; Associate colors-texture to GL texture unit 0 and associate the shader's
    ; 'nodeColors' sampler with the same unit.
    (glActiveTexture GL_TEXTURE0)
    (glBindTexture GL_TEXTURE_2D colors-texture)
    (set-uniform-1i program "nodeColors" 0)

    ; Pass view parameters and rendering config into shader.
    (set-uniform-1f   program "zoom"           zoom)
    (set-uniform-1f   program "closeEnough"    (1 . / . quality))
    (set-uniform-1i   program "stepLimit"      step-limit)
    (set-uniform-bool program "showComplexity" (eq? mode 'complexity))
    (set-uniform-bool program "showDistance"   (eq? mode 'distance))

    (set-uniform-2f program "resolution" width height)

    ; Pass the view rotation quaternion to the shader, inverting its rotation
    ; since the shader has to rotate rays to match the eye instead of vice
    ; versa.
    (let ([q (quat-conjugate orientation)])
      (set-uniform-4f program "orientation"
                      (vec3-x (quat-v q))
                      (vec3-y (quat-v q))
                      (vec3-z (quat-v q))
                      (quat-s q))))

  ; Draw a quad.  This sequence is taken nearly verbatim from the RacketGL
  ; example code.

  ; Notify OpenGL of the existence of our vertex array.
  (let-values ([(type cptr) (gl-vector->type/cpointer vertex-array)])
    (glVertexPointer 2 type 0 cptr))
  ; Enable its use.
  (glEnableClientState GL_VERTEX_ARRAY)
  ; Draw it once.
  (glDrawArrays GL_QUADS 0 4)

  ; Clean up.
  (glDisableClientState GL_VERTEX_ARRAY)
  (when program (glUseProgram 0)))


; ------------------------------------------------------------------------------
; Command line interface.

(define (spheretrace path)
  (set! design-path path)
  (view draw setup))

(command-line
  #:program "spheretrace"

  #:usage-help
  "Displays a design interactively using ray-tracing."

  #:ps
  ""
  "Keyboard/mouse usage:"
  "- Drag with the mouse to rotate the design."
  "- Scroll wheel / gesture zooms."
  "- F5 reloads and recompiles any changes to the design."

  #:args (design-path)
  (spheretrace design-path))
